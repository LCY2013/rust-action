fn sum(data: &Vec<u32>) -> u32 {
    // 值的地址会改变吗？引用的地址会改变吗？
    println!("addr of value:{:p}, addr of ref: {:p}", data, &data);
    data.iter().fold(0, |acc, val| acc + val)
}

/// 多个可变引用共存, 存在问题
/// 这段代码在遍历可变数组 data 的过程中，还往 data 里添加新的数据，这是很危险的动作，因为它破坏了循环的不变性（loop invariant），容易导致死循环甚至系统崩溃。
/// 所以，在同一个作用域下有多个可变引用，是不安全的。
fn mut_ref() {
    let mut data = vec![1, 2, 3, 4];

    // for item in data.iter_mut() {
    //     data.push(*item + 1);
    // }
}

/// 同一个上下文中多个可变引用是不安全的，那如果同时有一个可变引用和若干个只读引用，会有问题吗？
/// 在这段代码里，不可变数组 data1 引用了可变数组 data 中的一个元素，这是个只读引用。
/// 后续我们往 data 中添加了 100 个元素，在调用  data.push() 时，我们访问了 data 的可变引用。
/// 这段代码中，data 的只读引用和可变引用共存，似乎没有什么影响，因为 data1 引用的元素并没有任何改动。
/// 如果你仔细推敲，就会发现这里有内存不安全的潜在操作：如果继续添加元素，堆上的数据预留的空间不够了，就会重新分配一片足够大的内存，把之前的值拷过来，然后释放旧的内存。
/// 这样就会让 data1 中保存的 &data[0] 引用失效，导致内存安全问题。
fn context_mut_ref() {
    let mut data = vec![1, 2, 3, 4];
    // let data1 = vec![&data[0]];
    // println!("data[0]: {:p}", &data[0]);
    //
    // for i in 0..100 {
    //     data.push(i);
    // }
    //
    // println!("data[0]: {:p}", &data[0]);
    // println!("boxed: {:p}", &data1);
}

/*
Rust 的限制
多个可变引用共存、可变引用和只读引用共存这两种问题，通过 GC 等自动内存管理方案可以避免第二种，但是第一个问题 GC 也无济于事。
所以为了保证内存安全，Rust 对可变引用的使用也做了严格的约束：
1、在一个作用域内，仅允许一个活跃的可变引用。所谓活跃，就是真正被使用来修改数据的可变引用，如果只是定义了，却没有使用或者当作只读引用使用，不算活跃。
2、在一个作用域内，活跃的可变引用（写）和只读引用（读）是互斥的，不能同时存在。
这个约束你是不是觉得看上去似曾相识？对，它和数据在并发下的读写访问（比如 RwLock）规则非常类似，你可以类比学习。
从可变引用的约束我们也可以看到，Rust 不光解决了 GC 可以解决的内存安全问题，还解决了 GC 无法解决的问题。在编写代码的时候， Rust 编译器就像你的良师益友，不断敦促你采用最佳实践来撰写安全的代码。

1、一个值在同一时刻只有一个所有者。当所有者离开作用域，其拥有的值会被丢弃。赋值或者传参会导致值 Move，所有权被转移，一旦所有权转移，之前的变量就不能访问。
2、如果值实现了 Copy trait，那么赋值或传参会使用 Copy 语义，相应的值会被按位拷贝，产生新的值。
3、一个值可以有多个只读引用。
4、一个值可以有唯一一个活跃的可变引用。可变引用（写）和只读引用（读）是互斥的关系，就像并发下数据的读写互斥那样。
5、引用的生命周期不能超出值的生命周期。
 */

#[cfg(test)]
mod tests {
    use super::*;

    /*
    data1、&data 和传到 sum() 里的 data1’ 都指向 data 本身，这个值的地址是固定的。
    但是它们引用的地址都是不同的，这印证了 只读引用实现了 Copy trait，也就意味着引用的赋值、传参都会产生新的浅拷贝。
    虽然 data 有很多只读引用指向它，但堆上的数据依旧只有 data 一个所有者，所以值的任意多个引用并不会影响所有权的唯一性。

    一旦 data 离开了作用域被释放，如果还有引用指向 data，岂不是造成使用已释放内存（use after free）这样的内存安全问题？

    借用的生命周期及其约束
    所以，对值的引用也要有约束，这个约束是：借用不能超过（outlive）值的生存期。
     */
    #[test]
    fn it_works() {
        let data = vec![1, 2, 3, 4];
        let data1 = &data;
        // 值的地址是什么？引用的地址又是什么？
        println!(
            "addr of value: {:p}({:p}), addr of data {:p}, data1({:p})",
            &data,data1, &&data, &data1
        );

        println!("sum of data1: {}", sum(data1));

        // 栈上数据的地址是什么？
        println!(
            "addr of items: [{:p}, {:p}, {:p}, {:p}]",
            &data[0], &data[1], &data[2], &data[3]
        );
    }

    #[test]
    fn it_mut_ref() {
        mut_ref();
    }

    #[test]
    fn it_context_mut_ref() {
        context_mut_ref();
    }

}

